{"version":3,"sources":["App.tsx","components/Cinemagraph.tsx","preloadMedia.ts","serviceWorker.ts","index.tsx"],"names":["PlayState","Cinemagraph","videoRef","React","audioRef","bgAudioRef","ctx","window","AudioContext","webkitAudioContext","lastPauseTime","Date","_this2","this","current","addEventListener","props","onComplete","newProps","paused","getTime","load","play","pause","media","_this3","console","log","name","setState","src","video","dialog","audioData","srcNode","bgaudio","fetch","mode","then","resp","arrayBuffer","buffer","decodeAudioData","playLoop","abuffer","createBufferSource","connect","destination","loop","start","react","className","autoPlay","muted","playsInline","ref","App","_this","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","playerRef","createRef","progressBarRef","cache","videos","keypresses","playCoord","x","y","nextCoord","onKeyDown","e","state","playState","Complete","next","NotStarted","playIfNotPlaying","Playing","onTouchStart","clickedTouchPoint","stopAudio","index","keypressIndex","keyTimeout","loaded","loadingProgress","resizeViewport","vh","innerHeight","document","documentElement","style","setProperty","concat","names","onProgressUpdate","completedCount","totalCount","length","videoExtension","createElement","canPlayType","fetchURL","url","r","blob","URL","createObjectURL","promises","map","n","source","sources","Promise","all","results","promise","foo","percent","Math","floor","entries","forEach","preloadMedia","v","value","setTimeout","loadVideo","react_default","a","max","id","onClick","left","top","Cinemagraph_Cinemagraph","Component","Boolean","location","hostname","match","ReactDOM","render","src_App_0","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.2778ab63.chunk.js","sourcesContent":["import React, { Component, SyntheticEvent } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport Cinemagraph from './components/Cinemagraph';\nimport KeyIndicator from './components/KeyIndicator';\nimport { isAbsolute } from 'path';\nimport preloadMedia, { CacheEntry } from './preloadMedia';\n\nenum PlayState {\n  NotStarted = 0,\n  Playing = 1,\n  Complete = 2\n}\n\ninterface State {\n  index: number\n  keypressIndex: number\n  keyTimeout: number\n  playState: PlayState\n  loaded: boolean\n  loadingProgress: number\n}\n\ninterface Video {\n  name: string\n  keypresses?: string[]\n  playCoord?: { x: number, y: number }\n  nextCoord?: { x: number, y: number }\n}\n\nclass App extends Component<{}, State> {\n  private playerRef = React.createRef<Cinemagraph>()\n  private progressBarRef = React.createRef<HTMLProgressElement>()\n\n  private cache: { [name: string]: CacheEntry } = {}\n\n  videos: Video[] = [\n    {\n      name: \"bed\",\n      keypresses: [\"ArrowUp\"],\n      playCoord: { x: 20, y: 60 },\n      nextCoord: { x: 70, y: 60 }\n    },\n    {\n      name: \"shower\",\n      keypresses: [\"ArrowDown\"],\n      playCoord: { x: 40, y: 70 },\n      nextCoord: { x: 70, y: 50 }\n\n    },\n    {\n      name: \"street\",\n    },\n    {\n      name: \"parks\",\n    },\n    {\n      name: \"drugdealers\",\n    },\n    {\n      name: \"turkey\",\n    },\n    {\n      name: \"keepwalking\",\n    },\n    {\n      name: \"dolores\",\n    },\n    {\n      name: \"urethra\",\n    },\n    {\n      name: \"google\",\n    },\n    {\n      name: \"fork\",\n    },\n    {\n      name: \"slide\",\n    },\n    {\n      name: \"up\",\n    },\n    {\n      name: \"stumble\",\n    },\n    {\n      name: \"run\",\n    },\n    {\n      name: \"canal\",\n    },\n    {\n      name: \"across\",\n    },\n    {\n      name: \"slidetop\",\n    },\n  ]\n\n  constructor(props: any) {\n    super(props)\n    this.state = {\n      index: 0,\n      keypressIndex: 0,\n      keyTimeout: 1000,\n      playState: PlayState.NotStarted,\n      loaded: false,\n      loadingProgress: 0\n    }\n  }\n\n  componentDidMount() {\n    // Mobile viewport sizing hack from https://css-tricks.com/the-trick-to-viewport-units-on-mobile/\n    function resizeViewport() {\n      const vh = window.innerHeight * 0.01;\n      document.documentElement.style.setProperty('--vh', `${vh}px`);\n    }\n    window.addEventListener('resize', resizeViewport)\n    resizeViewport()\n\n    preloadMedia(this.videos.map(v => v.name), (percent) => {\n      if (this.progressBarRef.current) {\n        this.progressBarRef.current.value = percent\n      }\n    }).then(cache => {\n      this.cache = cache\n      this.setState({ loaded: true })\n\n      const video = this.videos[0]\n      const media = this.cache[video.name]\n      setTimeout(() => {\n        this.playerRef.current!.loadVideo(media)\n      }, 100)\n    })\n  }\n\n  render() {\n    console.log(\"Re-rendering\")\n\n    if (!this.state.loaded) {\n      return (\n        <div className=\"App\" >\n          <div className=\"video-wrapper\">\n            <div>Loading!</div>\n            <progress ref={this.progressBarRef} value={this.state.loadingProgress} max=\"100\" />\n          </div>\n        </div>\n      )\n    }\n\n    const video = this.videos[this.state.index]\n\n    let next;\n    if (this.state.playState === PlayState.NotStarted) {\n      next = <div id='next-wrapper'\n        onClick={this.clickedTouchPoint}\n        style={{\n          left: `${video.playCoord!.x}%`,\n          top: `${video.playCoord!.y}%`,\n        }}>\n        <div id='next' />\n      </div>\n    } else if (this.state.playState === PlayState.Complete) {\n      next = <div id='next-wrapper'\n        onClick={this.clickedTouchPoint}\n        style={{\n          left: `${video.nextCoord!.x}%`,\n          top: `${video.nextCoord!.y}%`,\n        }}>\n        <div id='next' />\n      </div>\n    }\n\n    return (\n      <div className=\"App\" >\n        <div className=\"video-wrapper\">\n          <Cinemagraph\n            media={this.cache[video.name]}\n            ref={this.playerRef}\n            onComplete={this.onComplete}>\n          </Cinemagraph >\n          {next}\n        </div>\n      </div >\n    );\n  }\n\n  onKeyDown = (e: KeyboardEvent) => {\n    if (this.state.playState === PlayState.Complete) {\n      this.next()\n    } else if (this.state.playState === PlayState.NotStarted) {\n      this.playerRef.current!.playIfNotPlaying()\n      this.setState({ playState: PlayState.Playing })\n    }\n  }\n\n  onTouchStart = (e: TouchEvent) => {\n    if (this.state.playState === PlayState.Complete) {\n      this.next()\n    } else if (this.state.playState === PlayState.NotStarted) {\n      this.playerRef.current!.playIfNotPlaying()\n      this.setState({ playState: PlayState.Playing })\n    }\n  }\n\n  clickedTouchPoint = () => {\n    // TODO: Remove touch delay on mobile\n    if (this.state.playState === PlayState.Complete) {\n      this.next()\n    } else if (this.state.playState === PlayState.NotStarted) {\n      this.playerRef.current!.playIfNotPlaying()\n      this.setState({ playState: PlayState.Playing })\n    }\n  }\n\n  stopAudio = () => {\n    if (!this.playerRef.current) { return }\n    this.playerRef.current.pause()\n  }\n\n  onComplete = () => {\n    console.log(\"Is complete!\")\n    this.setState({ playState: PlayState.Complete })\n  }\n\n  next() {\n    const index = (this.state.index >= this.videos.length - 1 ? 0 : this.state.index + 1)\n    this.setState({ index, keypressIndex: 0, playState: PlayState.NotStarted })\n\n    const video = this.videos[index]\n    const media = this.cache[video.name]\n\n    // TODO: The 100ms delay is necessay, but shouldn't be!\n    setTimeout(() => {\n      if (!this.playerRef.current) {\n        return\n      }\n      this.playerRef.current.loadVideo(media)\n    }, 10)\n  }\n}\n\nexport default App;\n","import * as React from 'react'\nimport { CacheEntry } from '../preloadMedia';\n\ninterface Props {\n  media: CacheEntry\n  onComplete?: () => void\n}\n\nexport default class Cinemagraph extends React.Component<Props> {\n  private videoRef = React.createRef<HTMLVideoElement>()\n  private audioRef = React.createRef<HTMLAudioElement>()\n  private bgAudioRef = React.createRef<HTMLAudioElement>()\n\n  private ctx = new (window.AudioContext || (window as any).webkitAudioContext)()\n\n  private lastPauseTime = new Date()\n\n  componentDidMount() {\n    if (!this.audioRef.current) { return }\n    this.audioRef.current.addEventListener('ended', () => {\n      if (this.props.onComplete) { this.props.onComplete() }\n    })\n  }\n\n  shouldComponentUpdate(newProps: Props) {\n    // lol\n    return false\n  }\n\n  public playIfNotPlaying() {\n    if (!this.audioRef.current) { return }\n    if (!this.audioRef.current.paused) return\n\n    const timeDiff = new Date().getTime() - this.lastPauseTime.getTime()\n    if (timeDiff > 5000) {\n      this.audioRef.current.load()\n    }\n    this.audioRef.current.play()\n  }\n\n  public pause() {\n    if (!this.audioRef.current) { return }\n    this.lastPauseTime = new Date()\n    this.audioRef.current.pause()\n  }\n\n  public loadVideo(media: CacheEntry) {\n    console.log(\"Loiading video\", media.name)\n    this.setState({ media })\n\n    if (this.videoRef.current) {\n      this.videoRef.current.src = media.video\n      this.videoRef.current.load()\n    }\n\n    if (this.audioRef.current) {\n      this.audioRef.current.src = media.dialog\n    }\n\n    // Background audio\n    const src = media.bgaudio\n    let audioData: any, srcNode: AudioBufferSourceNode;  // global so we can access them from handlers\n\n    const decode = (buffer: any) => {\n      this.ctx.decodeAudioData(buffer, playLoop)\n    }\n\n    fetch(src, { mode: \"cors\" }).then(function (resp) { return resp.arrayBuffer() }).then(decode);\n\n    // Sets up a new source node as needed as stopping will render current invalid\n    const playLoop = (abuffer: any) => {\n      if (!audioData) audioData = abuffer;  // create a reference for control buttons\n      srcNode = this.ctx.createBufferSource();  // create audio source\n      srcNode.buffer = abuffer;             // use decoded buffer\n      srcNode.connect(this.ctx.destination);    // create output\n      srcNode.loop = true;                  // takes care of perfect looping\n      srcNode.start();                      // play...\n    }\n  }\n\n\n\n  render() {\n    return (\n      <div>\n        <video className='cinemagraph' autoPlay loop muted playsInline ref={this.videoRef} />\n        <audio autoPlay loop ref={this.bgAudioRef} />\n        <audio ref={this.audioRef} />\n      </div>\n    )\n  }\n}","interface VideoSource {\n  bgaudio: string\n  dialog: string\n  name: string\n  video: string\n}\n\nexport interface CacheEntry {\n  bgaudio: string\n  dialog: string\n  name: string\n  video: string\n}\n\nexport default function preloadMedia(names: string[], onProgressUpdate: (percent: number) => void): Promise<{ [name: string]: CacheEntry }> {\n  // TODO: This can be more granular than just tracking each level of the game \n  let completedCount = 0\n  let totalCount = names.length\n  function wrapPromise<T>(promise: Promise<T>): Promise<T> {\n    return promise.then(foo => {\n      completedCount += 1\n      const percent = Math.floor((completedCount / totalCount) * 100)\n      onProgressUpdate(percent)\n      return foo\n    })\n  }\n\n  const videoEl = document.createElement('video')\n  const supportsWebm = (videoEl.canPlayType('video/webm') != '')\n  const videoExtension = (supportsWebm ? \"webm\" : \"mp4\")\n\n  let sources: VideoSource[] = names.map((n) => {\n    return {\n      bgaudio: `bgaudio/${n}.mp3`,\n      dialog: `dialog/${n}.mp3`,\n      name: n,\n      video: `cinemagraphs/${n}.${videoExtension}`\n    }\n  })\n\n  function fetchURL(url: string): Promise<string> {\n    return fetch(url, { mode: \"cors\" })\n      .then(r => r.blob())\n      .then(URL.createObjectURL)\n  }\n\n  let promises: Promise<CacheEntry>[] = sources.map(source => {\n    const sources = [source.bgaudio, source.dialog, source.video]\n    return Promise.all(sources.map(fetchURL)).then(results => {\n      return {\n        bgaudio: results[0],\n        dialog: results[1],\n        name: source.name,\n        video: results[2]\n      }\n    })\n  })\n\n  return Promise.all(promises.map(wrapPromise)).then(entries => {\n    let map: { [name: string]: CacheEntry } = {}\n    entries.forEach(e => {\n      map[e.name] = e\n    })\n    return map\n  })\n}","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}
{"version":3,"sources":["components/Cinemagraph.tsx","components/KeyIndicator.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Cinemagraph","videoRef","React","audioRef","bgAudioRef","lastPauseTime","Date","_this2","this","current","console","log","addEventListener","props","onComplete","newProps","file","paused","getTime","load","play","pause","react","className","autoPlay","loop","muted","playsInline","ref","src","concat","type","KeyIndicator","react_default","a","createElement","keyName","Component","App","_this","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","playerRef","createRef","timeoutId","videos","name","keypresses","onKeyDown","e","clearTimeout","video","state","index","key","keypressIndex","playIfNotPlaying","length","setState","window","setTimeout","stopAudio","keyTimeout","onTouchStart","Cinemagraph_Cinemagraph","KeyIndicator_KeyIndicator","Boolean","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.addd485c.chunk.js","sourcesContent":["import * as React from 'react'\n\ninterface Props {\n  file: String\n  onComplete?: () => void\n}\n\nexport default class Cinemagraph extends React.Component<Props> {\n  private videoRef = React.createRef<HTMLVideoElement>()\n  private audioRef = React.createRef<HTMLAudioElement>()\n  private bgAudioRef = React.createRef<HTMLAudioElement>()\n\n  private lastPauseTime = new Date()\n\n  componentDidMount() {\n    if (!this.audioRef.current) { return }\n    console.log(\"Mounted!\")\n    this.audioRef.current.addEventListener('ended', () => {\n      if (this.props.onComplete) { this.props.onComplete() }\n    })\n  }\n\n  shouldComponentUpdate(newProps: Props) {\n    return newProps.file !== this.props.file\n  }\n\n  public playIfNotPlaying() {\n    if (!this.audioRef.current) { return }\n    if (!this.audioRef.current.paused) return\n\n    const timeDiff = new Date().getTime() - this.lastPauseTime.getTime()\n    if (timeDiff > 5000) {\n      this.audioRef.current.load()\n    }\n    this.audioRef.current.play()\n  }\n\n  public pause() {\n    if (!this.audioRef.current) { return }\n    this.lastPauseTime = new Date()\n    this.audioRef.current.pause()\n  }\n\n  render() {\n    if (this.videoRef.current) {\n      this.videoRef.current.load()\n    }\n    if (this.audioRef.current) {\n      this.audioRef.current.load()\n    }\n\n    if (this.bgAudioRef.current) {\n      this.bgAudioRef.current.load()\n    }\n\n    return (\n      <div>\n        <video className='cinemagraph' autoPlay loop muted playsInline ref={this.videoRef}>\n          <source src={`cinemagraphs/${this.props.file}.webm`} type=\"video/webm\" />\n          <source src={`cinemagraphs/${this.props.file}.mp4`} type=\"video/mp4\" />\n        </video>\n\n        <audio autoPlay loop ref={this.bgAudioRef}>\n          <source src={`bgaudio/${this.props.file}.mp3`} type=\"audio/mp3\" />\n        </audio>\n\n        <audio ref={this.audioRef}>\n          <source src={`dialog/${this.props.file}.mp3`} type=\"audio/mp3\" />\n        </audio>\n      </div>\n    )\n  }\n}","import React from \"react\";\n\ninterface Props {\n  keyName: string\n}\n\nexport default class KeyIndicator extends React.Component<Props> {\n  render() {\n    return <div>\n      {this.props.keyName}\n    </div>\n  }\n}","import React, { Component, SyntheticEvent } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport Cinemagraph from './components/Cinemagraph';\nimport KeyIndicator from './components/KeyIndicator';\n\ninterface State {\n  index: number,\n  keypressIndex: number;\n  keyTimeout: number\n}\n\ninterface Video {\n  name: string\n  keypresses: string[]\n}\n\nclass App extends Component<{}, State> {\n  private playerRef = React.createRef<Cinemagraph>()\n  private timeoutId: number | undefined\n\n  videos: Video[] = [\n    {\n      name: \"bed\",\n      keypresses: [\"ArrowUp\"],\n    },\n    {\n      name: \"shower\",\n      keypresses: [\"ArrowDown\"]\n    },\n    {\n      name: \"bike\",\n      keypresses: [\"ArrowUp\", \"ArrowDown\"]\n    },\n    {\n      name: \"ubahn\",\n      keypresses: [\"ArrowLeft\", \"ArrowRight\"]\n    }\n  ]\n\n  constructor(props: any) {\n    super(props)\n    this.state = {\n      index: 0,\n      keypressIndex: 0,\n      keyTimeout: 1000\n    }\n  }\n\n  componentDidMount() {\n    window.addEventListener('keydown', this.onKeyDown)\n    window.addEventListener('touchstart', this.onTouchStart)\n  }\n\n  render() {\n    const video = this.videos[this.state.index]\n    const key = video.keypresses[this.state.keypressIndex]\n\n    return (\n      <div className=\"App\" >\n        <Cinemagraph\n          file={video.name}\n          ref={this.playerRef}\n          onComplete={this.onComplete} />\n        <KeyIndicator keyName={key} />\n      </div>\n    );\n  }\n\n  onKeyDown = (e: KeyboardEvent) => {\n    clearTimeout(this.timeoutId)\n\n    if (!this.playerRef.current) { return }\n    const video = this.videos[this.state.index]\n\n    if (e.key === video.keypresses[this.state.keypressIndex]) {\n      this.playerRef.current.playIfNotPlaying()\n\n      const keypressIndex = (this.state.keypressIndex >= video.keypresses.length - 1 ? 0 : this.state.keypressIndex + 1)\n      this.setState({ keypressIndex })\n\n      // The explicit window is to shut up the TS compiler, which grabs the Node version, because CRA requires @types/node to be installed\n      this.timeoutId = window.setTimeout(this.stopAudio, this.state.keyTimeout)\n    } else {\n      this.playerRef.current.pause()\n      this.setState({ keypressIndex: 0 })\n    }\n  }\n\n  onTouchStart = (e: TouchEvent) => {\n    clearTimeout(this.timeoutId)\n\n    if (!this.playerRef.current) { return }\n    const video = this.videos[this.state.index]\n\n    this.playerRef.current.playIfNotPlaying()\n\n    const keypressIndex = (this.state.keypressIndex >= video.keypresses.length - 1 ? 0 : this.state.keypressIndex + 1)\n    this.setState({ keypressIndex })\n\n    // The explicit window is to shut up the TS compiler, which grabs the Node version, because CRA requires @types/node to be installed\n    this.timeoutId = window.setTimeout(this.stopAudio, this.state.keyTimeout)\n  }\n\n  stopAudio = () => {\n    if (!this.playerRef.current) { return }\n    this.playerRef.current.pause()\n  }\n\n  onComplete = () => {\n    const index = (this.state.index >= this.videos.length - 1 ? 0 : this.state.index + 1)\n    this.setState({ index, keypressIndex: 0 })\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}